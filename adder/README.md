# ADDER
本节研究的是模拟器件构成加法器

## 材料
- 电阻
- 三态门 [ts]
- 电压跟随器 [vf]
- 电压比较器 [vc]

## 方法
考虑电路的 RC 效应导致延迟过大，我们选择并联电阻以减少 R。  

```
---------------------+     O
                     |     |
O---+--[A0====01R]-[mos]---+-----[vf]-+--[vc]=======[ts]=+
    |                      |          +--[vc]=======[ts]=+
---------------------+     |          |  ....  ...  .... |
    |                |     |          +--[vc]==bus==[ts]=+===<4bit + 1bit cf>
    +--[B0====01R]-[mos]---+
    |                      |
---------------------+     |
    |                |     |
    +--[A1====02R]-[mos]---+
    |                      |
---------------------+     |
    |                |     |
    +--[B1====02R]-[mos]---+
    |                      |
---------------------+     |
    |                |     |
    +--[A2====04R]-[mos]---+
    |                      |
---------------------+     |
    |                |     |
    +--[B2====04R]-[mos]---+
    |                      |
---------------------+     |
    |                |     |
    +--[A3====08R]-[mos]---+
    |                      |
---------------------+     |
    |                |     |
    +--[B3====08R]-[mos]---+


```


## 查表法
```
暂存进位：
- 用两位表示当前位的加法结果
Ax Bx R1 R0
0  0  0  0
0  1  0  1
1  0  0  1
1  1  1  0

对于 4bit 加法：
- 其结果的最大值不超过 11110b(30)，最多有 31 种不同的结果，需要占用 5bit 来表示其中一种
    A3 A2 A1 A0 | A
+   B3 B2 B1 B0 | B
----------------|
    C3 C2 C1 C0 | C

band = (A & B);
bxor = (A ^ B);
bsum = (A + B);

lut[key0:(band & 0x3) | (bxor & 0x3) << 2].set(
    key1:(band & 0xc) | (bxor & 0xc) >> 2, 
    val :(bsum)
);

消耗：
- (4 + 5) * 9bit * 9cell 存储器
- (2)gate * 3 * 2 解码器（约 3 行 3 列）
- (4)bit * 9 比较器

概念：
- 内部 key1 指示的是候选的 key。
  当通过 key0 得到内部 key1 列表，当列表中其中一个内部 key1 与外部 key1 匹配时，则该内部 key 对应的 val 就是 A + B 的结果
- 外部 key1 指示的是目标 key。
  通过 key0、key1 两个 key 可以确定唯一一个结果值

过程：
- 通过 key0 得到 pair<key1, val> 列表
- 得到的列表一共有 9 种可能的结果，将其中每一种都与外部 key1 比较，实际上有且仅有一个内部 key1 与之匹配
- 匹配 key1 对应的 val 为 A + B 的和

key1:val                                                                                                            | key0
1001 10100 | 0100 01000 | 1100 11000 | 0011 01100 | 0110 10000 | 0010 01000 | 0001 00100 | 1000 10000 | 0000 00000  | 0
1100 11010 | 0001 00110 | 0010 01010 | 1000 10010 | 0011 01110 | 1001 10110 | 0000 00010 | 0100 01010 | 0110 10010  | 1
0100 01100 | 1000 10100 | 0110 10100 | 0011 10000 | 0001 01000 | 1100 11100 | 0010 01100 | 1001 11000 | 0000 00100  | 2
0010 01110 | 0100 01110 | 0110 10110 | 1000 10110 | 1001 11010 | 0000 00110 | 0011 10010 | 0001 01010 | 1100 11110  | 3
0100 01001 | 0011 01101 | 1001 10101 | 0000 00001 | 0010 01001 | 0110 10001 | 0001 00101 | 1000 10001 | 1100 11001  | 4
                                                                                                                    | 5     ignore
1000 10101 | 1100 11101 | 0000 00101 | 0100 01101 | 0011 10001 | 1001 11001 | 0010 01101 | 0001 01001 | 0110 10101  | 6
                                                                                                                    | 7     ignore
0010 01010 | 0011 01110 | 0100 01010 | 0110 10010 | 1000 10010 | 1001 10110 | 0000 00010 | 0001 00110 | 1100 11010  | 8
0100 01100 | 0000 00100 | 0011 10000 | 0010 01100 | 1001 11000 | 1100 11100 | 0110 10100 | 1000 10100 | 0001 01000  | 9
                                                                                                                    | 10    ignore
                                                                                                                    | 11    ignore
1000 10011 | 0001 00111 | 0011 01111 | 0110 10011 | 0010 01011 | 0100 01011 | 1001 10111 | 1100 11011 | 0000 00011  | 12
                                                                                                                    | 13    ignore
                                                                                                                    | 14    ignore
                                                                                                                    | 15    ignore

三数加法器：
Ax Bx Cx R1 R0
0  0  0  0  0
0  0  1  0  1
0  1  0  0  1
0  1  1  1  0
1  0  0  0  1
1  0  1  1  0
1  1  0  1  0
1  1  1  1  1
...

```


## 传输门构成进位链
- 传输门 t-g
- 异或门 xor
- 与非门 nan
- 非门   not

```
                                        AB                      AB
                                        ||                      ||
                      +-----+----[xor]==++    +-----+----[xor]==++
                      |     |           ||    |     |           ||
                      |     V           ||    |     V           ||
                      |   [not]         ||    |   [not]         ||
                      |     |           ||    |     |           ||
                      |     *           ||    |     *           ||
                      |   [t-g]<-[nan]==++    |   [t-g]<-[nan]==++
                      |     |                 |     |
                      *     V                 *     V
[cf]----[t-g]---+---[t-g]---+---[t-g]---+---[t-g]---+--------------
          *     A                 *     A                 
          |     |                 |     |                 
          |   [t-g]<-[nan]==++    |   [t-g]<-[nan]==++    
          |     *           ||    |     *           ||    
          |     |           ||    |     |           ||    
          |   [not]         ||    |   [not]         ||    
          |     A           ||    |     A           ||    
          |     |           ||    |     |           ||    
          +-----+----[xor]==++    +-----+----[xor]==++    
                            ||                      ||    
                            AB                      AB    

原理：
当前位 Ax + Bx 只有三种可能的结果
- 一定产生进位      nand(A, B) -> 0
- 一定不产生进位    nor(A, B) -> 1
- 可能产生进位      xor(A, B) -> 1
对于第三种情况，我们不阻断进位链。其他两种情况则阻断上级进位链，并在本级设置对应的电平


为了解决传输门级联的 RC 效应：
- 使用类似跳表的结构
- 如果某一段 xor(Ax, Bx) 计算的结果为连续的 1，这该路径的进位链保持畅通。
  为了减少经过的传输门数量，我们在该区间单独设置一个传输门，只要满足条件，就只经过一个传输门
- 其实这是另一种形态的超前进位加法器


            +----[t-g]-----------------------------------------------------------------------+
            |                                                                                |
            |                     +----[t-g]-------------------------------------------------+
            |                     |                                                          |
            +----[t-g]------------|------------------------------------+                     |
            |                     |                                    |                     |
            |                     +----[t-g]---------------------------+                     |
            |                     |                                    |                     |
            +----[t-g]------------|------------------+--------[t-g]----|---------------------+
            |                     |                  |                 |                     |
------------+----[t-g]------------+----[t-g]---------+--------[t-g]----+------------[t-g]----+------------

```


## 迭代一致化加法器

```C++
// 复杂度：
// - log2(bit_width)

#define xuser mixc::none
#include"define/base_type.hpp"
#include"math/random.hpp"

struct x08{
    u08  l : 4;
    u08  h : 4;
    x08(){}
    x08(u08 v){
        *u08p(this) = v;
    }
};

int main(){
    using namespace xuser::inc;

    u32 a       = random<u32>();
    u32 b       = random<u32>();

    x08 * ap    = (x08 *) & a;
    x08 * bp    = (x08 *) & b;

    x08 c0a     = ap[0].l + bp[0].l;
    x08 c0b     = ap[0].l + bp[0].l + 1;

    x08 c1a     = ap[0].h + bp[0].h;
    x08 c1b     = ap[0].h + bp[0].h + 1;

    x08 c2a     = ap[1].l + bp[1].l;
    x08 c2b     = ap[1].l + bp[1].l + 1;

    x08 c3a     = ap[1].h + bp[1].h;
    x08 c3b     = ap[1].h + bp[1].h + 1;

    x08 c4a     = ap[2].l + bp[2].l;
    x08 c4b     = ap[2].l + bp[2].l + 1;

    x08 c5a     = ap[2].h + bp[2].h;
    x08 c5b     = ap[2].h + bp[2].h + 1;

    x08 c6a     = ap[3].l + bp[3].l;
    x08 c6b     = ap[3].l + bp[3].l + 1;

    x08 c7a     = ap[3].h + bp[3].h;
    x08 c7b     = ap[3].h + bp[3].h + 1;

    u32 x       = a + b;
    x08 cfx     = 0;
    x08 c0c     = cfx.h ? c0b : c0a;
    x08 c1c     = c0c.h ? c1b : c1a;

    c3a         = c2a.h ? c3b : c3a;
    c3b         = c2b.h ? c3b : c3a;

    //c4a / c4b
    c5a         = c4a.h ? c5b : c5a;
    c5b         = c4b.h ? c5b : c5a;

    //c6a / c6b
    c7a         = c6a.h ? c7b : c7a;
    c7b         = c6b.h ? c7b : c7a;

    x08 c2c     = c1c.h ? c2b : c2a;
    x08 c3c     = c1c.h ? c3b : c3a;
    x08 c4c     = c3c.h ? c4b : c4a;

    c6a         = c5a.h ? c6b : c6a;
    c6b         = c5b.h ? c6b : c6a;

    c7a         = c5a.h ? c7b : c7a;
    c7b         = c5b.h ? c7b : c7a;

    x08 c5c     = c4c.h ? c5b : c5a;
    x08 c6c     = c4c.h ? c6b : c6a;
    x08 c7c     = c4c.h ? c7b : c7a;

    u32 w       = 
        c0c.l       | c1c.l <<  4 | c2c.l <<  8 | c3c.l << 12 | 
        c4c.l << 16 | c5c.l << 20 | c6c.l << 24 | c7c.l << 28;
    return 0;
}

```
